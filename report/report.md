# Цель работы

Ознакомиться с принципами программирования собственных протоколов, 
созданных на основе TCP и UDP.

# Индивидуальное задание

Разработать клиент-серверную систему терминального доступа, позволяющую 
клиентам подсоединяться к серверу и выполнять элементарные команды 
операционной системы.

# Дополнительное задание

Протестировать программы с помощью сетевого эмулятора netem, чтобы 
эмулировать реальную сеть, с ограниченной пропускной способностью, 
потерей, дублированием, перемешиванием пакетов и ошибками передачи.  
В качестве параметров сети использовать GPRS/EDGE. С помощью Wireshark 
показать, как протокол и протокол транспортного уровня реагируют на 
различные ситуации.

# Программа работы

TCP:
1. Рассмотрение работы простейшего TCP сервера и клиента на ОС Linux и Windows
2. Создание многопоточного сервера на Linux для параллельного обслуживания 
клиенов с использованием средств синхронизации для разделяемых данных
3. Разработка собственного протокола на основе TCP для 
индивидуального задания
4. Реализация прикладного протокола: клиент и многопоточный сервер

UDP:
1. Модификация простейшего сервера и клиента для протокола работы по 
протоколу UDP на ОС Windows и Linux
2. Обеспечение надежности протокола UDP, посредством нумерации пакетов 
и временного контроля активности соединения

Выполнение индивидуального задания

# Ход работы
## Рассмотрение работы простейшего TCP сервера и клиента

Этапы создания серверного и клиентского соединения не отличаются в зависимости от платформы, кроме необходимости на Windows вызывать функцию WSAStartup() перед началом использования сокетов, а также WSACleanup() по завершении работы.

### TCP

В общем случае, для создания TCP-сервера необходимо выполнить следующие системные вызовы:
1. socket() - создает сокет
2. bind() - привязка созданного сокета к заданным IP-адресам и портам
3. listen() - переводит сокет в состояние прослушивания
4. accept() - принимает поступающие запросы на подключение и возвращает сокет для нового соединения
5. recv() - чтение данных от клиента из сокета, возвращенного на предыдущем шаге
6. send() - отправка данных клиенту
7. shutdown() - разрыв соединения с клиентом (может быть инициировано по-разному)
8. close() - для закрытия клиентского и слушающего сокетов

TCP-клиенты, в свою очередь, в простейшем виде выполняют следующую последовательность действий для открытия соединения, отправки и получения данных, а затем - завершения:
1. socket() - точно также создает сокет
2. connect() - установка соединения для сокета, который будет связан с серверным сокетом, порожденным вызовом accept()
3. send() - отправка данных серверу
4. recv() - прием данных от сервера
5. shutdown() - разрыв соединения с сервером
6. close() - закрывает сокет

### UDP

Для создания UDP-сервера не требуется наличие слушающего сокета и отдельных сокетов для каждого клиента, т.к. UDP не устанавливает логическое соединение. Вместе с тем, мы можем - если там угодно - принимать данные от клиентов на одном сокете с хорошо известным портом, а отправлять данные с другого сокета, созданного специально для работы с клиентом, от которого были получены данные. Только клиент должен знать, с какого порта придут данные. Таким образом, при использовании UDP и клиент, и сервер могут меняться ролями.

Но все же, типичным подходом при реализации сервера могут служить следующие шаги:
1. socket() - первичная функция в мире API сокетов Беркли
2. bind() - сервер должен прослушивать указанный порт на локальном сетевом интерфейсе
3. recvfrom() - получает данные, полученные от клиента, параметры которого заполняются функцией
4. sendto() - отправка данных с указанием параметров клиента, полученных из прердущего шага
5. close() - освобождает сокет

Для UDP-клиент все несколько сложнее. Для клиента могут быть использованы вызовы connect() и bind(), но они не всегда обязательны.

Клиент может вызвать bind(), если нужно, чтобы у сокета был *указанный порт и адрес*, на который можно отправлять серверу данные. В противном случае при вызове send()/sendto()/recv()/recvfrom() номер порта и сетевой интерфейс будут назначены автоматически. Порт выбирается из [динамического диапазона портов](https://en.wikipedia.org/wiki/Ephemeral_port). А интерфейс - тот, с которого пакеты будут маршрутизироваться при сетевом обмене с сервером.

Функция connect() также может быть применена UDP-клиентом, тогда сокет будет считаться подключенным - нельзя вызывать sendto() на этом сокете, потому что этот вызов - частный случай connect(): вызов sendto() подключает сокет, отправляет датаграмму и отключает сокет. А подключать уже подключенный сокет нельзя. Получается, что использование connect() снижает накладные расходы при отправке данных. Кроме того, если вызвать connect() для адреса сервера и порта, который закрыт, затем вызвать send(), то вернется ошибка "Connection refused", чего не произошло бы в случае с sendto(). Это так, потому что когда sendto() возвращает управление, стек TCP/IP перестает следить за соединением, ведь сокет уже было отсоединен перед выходом из sendto(). Поэтому ICMP сообщения не доходят до приложения.

Итак, ниже приводится примерная последовательность действий, которые выполняются UDP-клиентом для обмена данными с UDP-сервером:
1. socket() - создает сокет
2. connect() - подключает сокет с параметрами удаленного узла
3. send() - этот вызов выполнит неявный bind() и отправит данные
4. recv() - получит данные с порта и адреса, назначенными автоматически в предыдущем шаге
5. close() - закрывает сокет

## Создание многопоточного TCP-сервера

Чтобы сервер параллельно обрабатывал клиентские подключения, можно каждый сокет, возвращенный из accept(), передавать в отдельный поток, который будет выполнять обмен и все необходимые действия независимо от серверной нити исполнения и других потоков. Если есть разделяемые данные, то доступ к ним должен быть синхронизирован, например, мьютексами.

Схематично работу сервера можно описать алгоритмом, представленным ниже:
<img src="res/mt-routine.png" alt="Общая идея, лежащая в основе работы сервера" width="100%" height="100%">
Cервер открывает прослушивающий сокет (listenSocket) и запускает поток, в котором, в цикле, принимает входящие TCP-соединения (функция потока acceptConnections()). Параллельное обслуживание клиентов осуществляется благодаря созданию отдельного потока (echoHandler()) под каждый сокет, возвращенный вызовом accept(). Сервер запоминает метаданные о принятом соединении: а) сокет нового соединения; б) дескриптор потока, в котором обслуживается соединение. Кроме того, сервер следит за тем, чтобы общее число соединений не превышало некоторое ограничение, ведь ресурсы системы ограничены. Каждому подключению может назначаться уникальный номер для идентификации соединений и управления ими. Поток, обслуживающий клиентские соединения, в цикле получает данные от клиента и отправляет их обратно. Основной поток сервера читает данные с консоли и обрабатывать команды: завершение работы сервера, отключение клиента от сервера и проч. Если была запрошена команда завершения сервера, то достаточно закрыть слушающий сокет, что вызовет ошибку и цикл приема новых подключений прервется. Далее выполняется функция закрытия всех клиентских сокетов. При их закрытии завершатся соответствующие потоки: цикл прервется по ошибке из recv()/send() и поток дойдет до точки прерывания. Сервер после закрытия всех сокетов должен ожидать завершения всех запущенных ранее потоков, а также освободить прочие ресурсы и завершиться.

Данный способ реализации параллельной обработки соединений хорош своей простотой реализации и эффективностью обслуживания, пока число клиентов невелико. Порождение новых потоков - довольно затратная операция. Данная проблема решалась бы созданием пула потоков, если бы на практике число соединений не исчислялось тысячами. Держать десятки потоков - расточительство.

Другой вариант - применение средств мультиплексирования ввода-вывода. В простейшем варианте для этого можно использовать select(): функция ждет событий в наборе отслеживаемых сокетов. Если сокет находится в наборе для чтения данных, то можно применить на активном сокете операцию recv(), обработать запрос (и отправить ответ, если нужно). Если запрос требует длительной обработки, то эту задачу можно отдать в поток/процесс, а результат отправить позже.

Третий вариант - создать пул процессов/потоков (назовем их воркерами) и складывать принятые соединения в общую очередь сокетов. Тогда незанятые воркеры могут ждать появления дескрипторов в очереди, обработать клиентский запрос, а после завершения работы снова возвращаться к ожиданию новых клиентов. Такая модель весьма эффективна и может быть улучшена. Так, можно создать по одному процессу на ядро процессора, а принятые файловые дескрипторы передавать вокером через механизм передачи файлового дескриптора в Linux (fd-passing) или дублирование сокета (WSADuplicateSocket()) в Windows. Сервер будет распределять сокеты по воркерам в зависимости от их занятости и размера индивидуальной очереди необработанных сокетов. Внутри каждого процесса-воркера может быть по нескольку потоков. В случае, если воркер аварийно завершился, сервер должен создать нового воркера.

Разумеется, это не все возможные приемы для решения задачи параллельной обработки клиентских подключений и данных. Но все эти подходы могут служить основой при реализации сетевых серверных программ.

Вариант с потоками был мною реализован в рамках выполнения индивидуального задания для TCP-сервера на Linux. Там под каждое соединение создавался поток, но не больше 20 потоков в общей сложности. А мультиплексирование I/O я использовал в UDP-сервере на Windows, где также не позволял серверу работать больше, чем с двадцатью клиентами одновременно. Ограничение в 20 клиентов в первом случае обусловлено тем, что не хотелось бы отводить больше двадцати потоков. А во втором - для общности реализация серверов с разными транспортными протоколами: команды в моем индивидуальном задании обычно крайне простые, и можно быстро обрабатывать запросы и переходить к следующим задачам - все в один поток.

Третий вариант я не стал реализовать, поскольку, на мой взгляд, это излишне для лабораторной работы. К тому же, у меня уже есть опыт реализации сервера с такой моделью обслуживания.

## Разработка прикладного протокола

