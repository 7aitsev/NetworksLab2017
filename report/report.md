# Цель работы

Ознакомиться с принципами программирования собственных протоколов, 
созданных на основе TCP и UDP.

# Индивидуальное задание

Разработать клиент-серверную систему терминального доступа, позволяющую 
клиентам подсоединяться к серверу и выполнять элементарные команды 
операционной системы.

# Дополнительное задание

Протестировать программы с помощью сетевого эмулятора netem, чтобы 
эмулировать реальную сеть, с ограниченной пропускной способностью, 
потерей, дублированием, перемешиванием пакетов и ошибками передачи.  
В качестве параметров сети использовать GPRS/EDGE. С помощью Wireshark 
показать, как протокол и протокол транспортного уровня реагируют на 
различные ситуации.

# Программа работы

TCP:
1. Рассмотрение работы простейшего TCP сервера и клиента на ОС Linux и Windows
2. Создание многопоточного сервера на Linux для параллельного обслуживания 
клиенов с использованием средств синхронизации для разделяемых данных
3. Разработка собственного протокола на основе TCP для 
индивидуального задания
4. Реализация прикладного протокола: клиент и многопоточный сервер

UDP:
1. Модификация простейшего сервера и клиента для протокола работы по 
протоколу UDP на ОС Windows и Linux
2. Обеспечение надежности протокола UDP, посредством нумерации пакетов 
и временного контроля активности соединения

Выполнение индивидуального задания

# Ход работы
## Рассмотрение работы простейшего TCP сервера и клиента

Этапы создания серверного и клиентского соединения не отличаются в зависимости от платформы, кроме необходимости на Windows вызывать функцию WSAStartup() перед началом использования сокетов, а также WSACleanup() по завершении работы.

### TCP

В общем случае, для создания TCP-сервера необходимо выполнить следующие системные вызовы:
1. socket() - создает сокет
2. bind() - привязка созданного сокета к заданным IP-адресам и портам
3. listen() - переводит сокет в состояние прослушивания
4. accept() - принимает поступающие запросы на подключение и возвращает сокет для нового соединения
5. recv() - чтение данных от клиента из сокета, возвращенного на предыдущем шаге
6. send() - отправка данных клиенту
7. shutdown() - разрыв соединения с клиентом (может быть инициировано по-разному)
8. close() - для закрытия клиентского и слушающего сокетов

TCP-клиенты, в свою очередь, в простейшем виде выполняют следующую последовательность действий для открытия соединения, отправки и получения данных, а затем - завершения:
1. socket() - точно также создает сокет
2. connect() - установка соединения для сокета, который будет связан с серверным сокетом, порожденным вызовом accept()
3. send() - отправка данных серверу
4. recv() - прием данных от сервера
5. shutdown() - разрыв соединения с сервером
6. close() - закрывает сокет

### UDP

Для создания UDP-сервера не требуется наличие слушающего сокета и отдельных сокетов для каждого клиента, т.к. UDP не устанавливает логическое соединение. Вместе с тем, мы можем - если там угодно - принимать данные от клиентов на одном сокете с хорошо известным портом, а отправлять данные с другого сокета, созданного специально для работы с клиентом, от которого были получены данные. Только клиент должен знать, с какого порта придут данные. Таким образом, при использовании UDP и клиент, и сервер могут меняться ролями.

Но все же, типичным подходом при реализации сервера могут служить следующие шаги:
1. socket() - первичная функция в мире API сокетов Беркли
2. bind() - сервер должен прослушивать указанный порт на локальном сетевом интерфейсе
3. recvfrom() - получает данные, полученные от клиента, параметры которого заполняются функцией
4. sendto() - отправка данных с указанием параметров клиента, полученных из прердущего шага
5. close() - освобождает сокет

Для UDP-клиент все несколько сложнее. Для клиента могут быть использованы вызовы connect() и bind(), но они не всегда обязательны.

Клиент может вызвать bind(), если нужно, чтобы у сокета был *указанный порт и адрес*, на который можно отправлять серверу данные. В противном случае при вызове send()/sendto()/recv()/recvfrom() номер порта и сетевой интерфейс будут назначены автоматически. Порт выбирается из [динамического диапазона портов](https://en.wikipedia.org/wiki/Ephemeral_port). А интерфейс - тот, с которого пакеты будут маршрутизироваться при сетевом обмене с сервером.

Функция connect() также может быть применена UDP-клиентом, тогда сокет будет считаться подключенным - нельзя вызывать sendto() на этом сокете, потому что этот вызов - частный случай connect(): вызов sendto() подключает сокет, отправляет датаграмму и отключает сокет. А подключать уже подключенный сокет нельзя. Получается, что использование connect() снижает накладные расходы при отправке данных. Кроме того, если вызвать connect() для адреса сервера и порта, который закрыт, затем вызвать send(), то вернется ошибка "Connection refused", чего не произошло бы в случае с sendto(). Это так, потому что когда sendto() возвращает управление, стек TCP/IP перестает следить за соединением, ведь сокет уже было отсоединен перед выходом из sendto(). Поэтому ICMP сообщения не доходят до приложения.

Итак, ниже приводится примерная последовательность действий, которые выполняются UDP-клиентом для обмена данными с UDP-сервером:
1. socket() - создает сокет
2. connect() - подключает сокет с параметрами удаленного узла
3. send() - этот вызов выполнит неявный bind() и отправит данные
4. recv() - получит данные с порта и адреса, назначенными автоматически в предыдущем шаге
5. close() - закрывает сокет

## Создание многопоточного TCP-сервера

